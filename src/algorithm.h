#ifndef TINYSTL_SRC_ALGORITHM_H_#define TINYSTL_SRC_ALGORITHM_H_#include "functional.h"#include "iterator.h"#include "type_traits.h"namespace TinySTL {/***************** [swap] T(n) = O(1) *********************/// TODO：一次拷贝构造，两次 assignment operator，一次析构，可以说很低效template<typename T>inline voidswap(T &a, T &b) {  T tmp = a;  a = b;  b = tmp;}/***************** [push_heap] T(n) = O(lgn) *********************//// 将 last - 1 元素按 heap 的规则放在适合的位置。/// 说明：如果当前节点大于父节点，交换之。template<typename RandomAccessIterator, typename Compare>inline void// 移动次数为 n，则 ctor: n, assignment operator: 2n, dtor: npush_heap_less_eff(RandomAccessIterator first, RandomAccessIterator last, Compare cmp) {  auto cur = last - 1;  auto parent = first + (cur - first + 1) / 2;  while (cur != first && cmp(*parent, *cur)) {    TinySTL::swap(*parent, *cur);    cur = parent;    parent = first + (cur - first + 1) / 2;  }}//template<typename RandomAccessIterator, typename Compare>void// 移动次数为 n，则 ctor: 1, assignment operator: n, dtor: 1. 比上面优化很多// 注意 iterator + offset 和 offset + iterator 写法的区别push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare cmp) {  auto value = *(last - 1);  auto cur_index = last - first - 1;  auto parent_index = (cur_index - 1) / 2;  while (cur_index > 0 && cmp(*(first + parent_index), value)) {    *(first + cur_index) = *(first + parent_index);    cur_index = parent_index;    parent_index = (cur_index - 1) / 2;  }  *(first + cur_index) = value;}template<typename RandomAccessIterator>voidpush_heap(RandomAccessIterator first, RandomAccessIterator last) {  TinySTL::push_heap(first, last, typename TinySTL::less<typename iterator_traits<RandomAccessIterator>::value_type>());}/***************** [pop_heap] T(n) = O(lgn) *********************/template<typename RandomAccessIterator, typename Compare>void/// 将 first 与 last - 1交换，并调整 heap。/// 说明： 1.交换 first 和 last - 1，2. 找到新的first元素的适合位置。pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare cmp) {  auto value = *(last - 1);  *(last - 1) = *first;  // 减一是因为 last - 1已经不是 heap 的元素了  auto len = last - first - 1;  auto cur_index = 0;  auto right_child_index = 2 * cur_index + 2;  auto max_child_index = right_child_index;  // 因为 value 是从叶子节点取的，所以最终位置也一定是叶子节点。而叶子节点的子节点一定大于 len。  while (right_child_index < len) {    max_child_index = cmp(*(first + right_child_index), *(first + (right_child_index - 1))) ?                      right_child_index - 1 :                      right_child_index;    *(first + cur_index) = *(first + max_child_index);    cur_index = max_child_index;    right_child_index = 2 * cur_index + 2;  }  // 处理特殊情况，没有右节点，只有左节点  if (right_child_index == len && cmp(*(first + cur_index), *(first + right_child_index - 1))) {    *(first + cur_index) = *(first + max_child_index);    cur_index = max_child_index;  }  *(first + cur_index) = value;}template<typename RandomAccessIterator>voidpop_heap(RandomAccessIterator first, RandomAccessIterator last) {  TinySTL::pop_heap(first, last, typename TinySTL::less<typename iterator_traits<RandomAccessIterator>::value_type>());}/***************** [make_heap] T(n) = O(n) *********************/template<typename RandomAccessIterator, typename Compare>voidmake_heap(RandomAccessIterator first, RandomAccessIterator last, Compare cmp) {  auto len = last - first;  for (auto last_index = len - len + 1; last_index <= len; ++last_index)    TinySTL::push_heap(first, first + last_index, cmp);}template<typename RandomAccessIterator>voidmake_heap(RandomAccessIterator first, RandomAccessIterator last) {  TinySTL::make_heap(first, last, typename TinySTL::less<typename iterator_traits<RandomAccessIterator>::value_type>());}/***************** [sort_heap] T(n) = O(nlgn) *********************/template<typename RandomAccessIterator, typename Compare>voidsort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare cmp) {  while (last - first > 1)    TinySTL::pop_heap(first, last--);}template<typename RandomAccessIterator>voidsort_heap(RandomAccessIterator first, RandomAccessIterator last) {  TinySTL::sort_heap(first, last, typename TinySTL::less<typename iterator_traits<RandomAccessIterator>::value_type>());}/***************** [is_heap] T(n) = O(n) *********************//***************** [max] T(n) = O(1) *********************/template<typename T>inline const T &max(const T &a, const T &b) {  return a < b ? b : a;}template<typename T, typename Compare>inline const T &max(const T &a, const T &b, Compare comp) {  return comp(a, b) ? b : a;}/***************** [min] T(n) = O(1) *********************/template<typename T>inline const T &min(const T &a, const T &b) {  return a < b ? a : b;}template<typename T, typename Compare>inline const T &mix(const T &a, const T &b, Compare comp) {  return comp(a, b) ? a : b;}/***************** [fill] T(n) = O(n) *********************/template<typename ForwardIterator, typename T>inline voidfill(ForwardIterator first, ForwardIterator last, const T &val) {  for (; first != last; ++first)    *first = val;}inline voidfill(char *first, char *last, const char &val) {  memset(first, static_cast<unsigned char>(val), last - first);}/***************** [fill-n] T(n) = O(n) *********************/template<typename OutputIterator, typename Size, typename T>inline OutputIteratorfill_n(OutputIterator first, Size n, const T &val) {  for (; n > 0; --n, ++first)    *first = val;  return first;}template<typename Size>inline char *fill_n(char *first, Size n, const char &val) {  memset(first, static_cast<unsigned char>(val), n);  return first + n;}/***************** [copy-backward] T(n) = O(n) *********************/// 出口一：assignment operator: 其他template<typename InputIterator, typename BidirectionalIterator>inline BidirectionalIterator__copy_backward(InputIterator first, InputIterator last, BidirectionalIterator result) {  --last;  --result;  for (auto n = TinySTL::distance(first, last); n > 0; --n, --result, --last)    *result = *last;  return result;}// 出口二：memmove，条件：原生指针 + has_trivial_assignment_operatortemplate<typename T>inline T *__copy_t_backward(const T *first, const T *last, T *result, __true_type) {  auto dist = last - first;  memmove(result - dist, first, sizeof(T) * dist);  return result - dist;}template<typename T>inline T *__copy_t_backward(const T *first, const T *last, T *result, __false_type) {  return TinySTL::__copy_backward(first, last, result);}template<typename InputIterator, typename OutputIterator>struct __copy_dispatch_backward {  OutputIterator operator()(InputIterator first, InputIterator last, OutputIterator result) {    return __copy_backward(first, last, result);  }};template<typename T>struct __copy_dispatch_backward<T *, T *> {  T *operator()(T *first, T *last, T *result) {    typedef typename __type_traits<T>::has_trivial_assignment_operator t;    return __copy_t_backward(first, last, result, t());  }};template<typename T>struct __copy_dispatch_backward<const T *, T *> {  T *operator()(const T *first, const T *last, T *result) {    typedef typename __type_traits<T>::has_trivial_assignment_operator t;    return __copy_t_backward(first, last, result, t());  }};template<typename InputIterator, typename OutputIterator>inline OutputIteratorcopy_backward(InputIterator first, InputIterator last, OutputIterator result) {  return __copy_dispatch_backward<InputIterator, OutputIterator>()(first, last, result);}inline char *copy_backward(const char *first, const char *last, char *result) {  auto dist = last - first;  memmove(result - dist, first, dist);  return result - dist;}/***************** [copy] T(n) = O(n) *********************/// 出口一：assignment operator: 其他template<typename InputIterator, typename OutputIterator>inline OutputIterator__copy(InputIterator first, InputIterator last, OutputIterator result) {  for (auto n = TinySTL::distance(first, last); n > 0; --n, ++result, ++first)    *result = *first;  return result;}// 出口二：memmove，条件：原生指针 + has_trivial_assignment_operatortemplate<typename T>inline T *__copy_t(const T *first, const T *last, T *result, __true_type) {  memmove(result, first, sizeof(T) * (last - first));  return result + (last - first);}template<typename T>inline T *__copy_t(const T *first, const T *last, T *result, __false_type) {  return __copy(first, last, result);}template<typename InputIterator, typename OutputIterator>struct __copy_dispatch {  OutputIterator operator()(InputIterator first, InputIterator last, OutputIterator result) {    return TinySTL::__copy(first, last, result);  }};template<typename T>struct __copy_dispatch<T *, T *> {  T *operator()(T *first, T *last, T *result) {    typedef typename __type_traits<T>::has_trivial_assignment_operator t;    return __copy_t(first, last, result, t());  }};template<typename T>struct __copy_dispatch<const T *, T *> {  T *operator()(const T *first, const T *last, T *result) {    typedef typename __type_traits<T>::has_trivial_assignment_operator t;    return __copy_t(first, last, result, t());  }};template<typename InputIterator, typename OutputIterator>inline OutputIteratorcopy(InputIterator first, InputIterator last, OutputIterator result) {  return __copy_dispatch<InputIterator, OutputIterator>()(first, last, result);}inline char *copy(const char *first, const char *last, char *result) {  memmove(result, first, last - first);  return result + (last - first);}inline wchar_t *copy(const wchar_t *first, const wchar_t *last, wchar_t *result) {  memmove(result, first, sizeof(wchar_t) * (last - first));  return result + (last - first);}}#endif //TINYSTL_SRC_ALGORITHM_H_